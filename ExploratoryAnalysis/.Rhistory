p_eva <- exp(72/100)/(exp(72/100)+exp(0.06125))
p_eva
m_binlog <- function(t1,c1,t2,c2,inc,univ)
{
vc <- 1-3/100*t1-6/100*c1+0.5*inc
vt <- -2/100*t2-3.75/100*c2+0.5*univ
p <- exp(vc)/(exp(vc)+exp(vt))
}
p_eva2 <- m_binlog(22,18,2,2.1,1,1)
p_eva2
eva2
p_eva
m_binlog <- function(t1,t2,c1,c2,inc,univ)
{
vc <- 1-3/100*t1-6/100*c1+0.5*inc
vt <- -2/100*t2-3.75/100*c2+0.5*univ
p <- exp(vc)/(exp(vc)+exp(vt))
return(c(vc,vt,p))
}
p_eva2 <- m_binlog(22,18,2,2.1,1,1)
p_eva2
m_binlog <- function(t1,t2,c1,c2,inc,univ)
{
vc <- 1-3/100*t1-6/100*c1+0.5*inc
vt <- -2/100*t2-3.75/100*c2+0.5*univ
p <- exp(vc)/(exp(vc)+exp(vt))
return(p)
}
p_eva2 <- m_binlog(22,18,2,2.1,1,1)
p_eva2
p_matth <- m_binlog(120,100,10,15,0,1)
p_michel <- m_binlog(10,50,3,5,1,0)
p_meri <- m_binlog(25,9,7,2.1,0,0)
p_eva
p_matth
p_meri
p_michel
help(time_zone_converter)
rm(list=ls())
eval_confusion(make_confusion(sick_times,not_sick_times, cut = mean(result$hist)),fOne=TRUE)
make_confusion(sick_times,not_sick_times, cut = mean(result$hist))
leave_one_out <- function(negative, positive, ...)
{
optimal_score = -99999999
log2(4/3)
log2(4/3)*2
(4/3)**(4)
(4/3)**(5)
y <- function(x,a,c){
y <- a*log(n)-a*n*log(4/3)-a*log(4/3)+c*N
}
funct1 <- function(x,a,c){
y <- a*log(n)-a*n*log(4/3)-a*log(4/3)+c*N
}
x <- seq(1,100)
y <- funct1(x,2,1)
y <- funct1(x,a,c,n)
n <- 100
x <- seq(1,n)
a <- 2
c <- 1
y <- funct1(x,a,c,n)
y
y
funct1 <- function(x,a,c,n){
y <- a*log(n)-a*n*log(4/3)-a*log(4/3)+c*N
}
n <- 100
x <- seq(1,n)
a <- 2
c <- 1
y <- funct1(x,a,c,n)
funct1 <- function(x,a,c,n){
y <- a*log(n)-a*n*log(4/3)-a*log(4/3)+c*n
}
n <- 100
x <- seq(1,n)
a <- 2
c <- 1
y <- funct1(x,a,c,n)
y
help(lapply)
y <- lapply(x, funct1, a,c,n)
y
x
funct1(1,a,c,n)
funct1(1,a,c,n)
funct1 <- function(x,a,c,n){
y <- a*log(n)-a*n*log(4/3)-a*log(4/3)+c*n
y
}
funct1(1,a,c,n)
funct1(2,a,c,n)
funct1(3,a,c,n)
a*log(n)
-a*n*log(4/3)
y <- lapply(n, funct1, a,c)
funct1 <- function(n,a,c){
y <- a*log(n)-a*n*log(4/3)-a*log(4/3)+c*n
y
}
n <- seq(1,n)
a <- 2
funct1 <- function(n,a,c){
y <- a*log(n)-a*n*log(4/3)-a*log(4/3)+c*n
y
}
n <- seq(1,100)
a <- 2
c <- 1
y <- lapply(n, funct1, a,c)
y
n <- seq(1,100)
a <- 5
c <- 1
y <- lapply(n, funct1, a,c)
y
2*c/log(4/3)
a <- 8
c <- 1
y <- lapply(n, funct1, a,c)
funct1(1,a,c,n)
y
y Ã¼1
y[1]
funct2 <- function(n,a,c){
y <- a*log(3*n/4)-a*log((4/3)**n)
}
funct2 <- function(n,a,c){
y <- a*log(3*n/4)-a*log((4/3)**n)
y
}
funct2(n,a,c)
a <- 1
funct2(n,a,c)
log(3/4)
log(6/4)
6/4
(4/3)**2
4/3
log(2/3)
log(1/2)
log(1/2)
log(2/3)
log(1/2)
sqrt(0.69**2+(6.33e-7)**2)
sqrt(0.69**2+(6.33e-7)**2)*6371
sqrt(0.6933**2+(6.33e-7)**2)*6371
install.packages("rJava")
install.packages("rJava")
.libPaths()
library(rJava)
install.packages("RWeka",depencies=T)
install.packages("RWekajars",depencies=T)
install.packages("RWekajars",dependencies=T)
install.packages("RWeka",dependencies=T)
library(tm)
install.packages("tm")
install.packages("tm",dependencies=T)
install.packages("slam",dependencies=T)
library("gridExtra") #for saving png files in a specific order into pdf
library("ggplot2")
library('ggdendro')
library("ggmap") #used to plot maps
library("maps")
library("scales") # for function alpha()
library("compiler")  # to speed up the computations!
library("plyr")
library("rgeos") #for creating maps
library("png") #for reading png files
library("grid") #for arranging png files
library("data.table") #for faster creation of crosstables from data set & for faster searches of datatables; brings about a lot of speed-up! https://github.com/Rdatatable/data.table/wiki/Getting-started
library("bit64") #for loading data with fread
library("lubridate") #for handling time and date information; http://stackoverflow.com/questions/10705328/extract-hours-and-seconds-from-posixct-for-plotting-purposes-in-r
#install.packages("devtools") > for install_github
#install_github("rundel/timezone") #needs terminal commands: http://stackoverflow.com/questions/33381421/how-to-upgrade-proj4-for-rgdal
#sudo apt-get install libgdal-dev libproj-dev
library("timezone") #for getting timezones from lat/long data
library("feather") #for fast exporting and importing of data: http://blog.revolutionanalytics.com/2016/05/feather-package.html
#other possibility for fast exporting data is fwrite() using the data.table package: http://blog.h2o.ai/2016/04/fast-csv-writing-for-r/
root_path <- "~/Dropbox/UZH_Master/Masterarbeit/TwitterEpi/ExploratoryAnalysis/" # defining root_path containing all relevant documents
script_path <- "~/Dropbox/UZH_Master/Masterarbeit/TwitterEpi/Non_R_Code/"
setwd(paste0(root_path,"functions/"))
file.sources = list.files(pattern="*.R")
sapply(file.sources,source,.GlobalEnv)
setwd(root_path) # set WD back
#source("datasets/load_csv.R")
#source("datasets/load_feather.R")
#if neither of the above two scripts has been excecuted, you must uncomment it in order to get dataset for further analysis
load(file="datasets/sick_tweets.RData")
# EXPLORATORY DATA ANALYSIS ------
df_label <- "sick" #or healthy, depending on dataset
#select only tweets from mainland USA
coord_USA <- c(-125,-66,25,50)
selec_coords <- coord_selection(df,coord_USA)
df <- selec_coords[[1]]
rm(selec_coords)
gc()
df_summary <- data_summary(df)
double_decker_plus(df_summary$dis_table,"sick","plots/")
library("plotrix")
library("hexbin") #for hexagonal binning
library("ggplot2") #the ggplot2 way: http://docs.ggplot2.org/0.9.3.1/stat_binhex.html
datatable <- df
cr <- colorRampPalette(c("green","blue"))
xbins = 100
coord_cont <- c(-125,-66,25,50) #select only tweets from mainland USA
xbnds <- coord_cont[1:2]
ybnds <- coord_cont[3:4]
shape = abs(coord_cont[3]-coord_cont[4])/abs(coord_cont[1]-coord_cont[2])
img_names <- c("alltweets_cont","sicktweets_cont","healthytweets_cont","mislabelled_cont","alltweets_local", "sicktweets_local", "healthytweets_local","mislabelledtweets_local")
filenames <- paste(img_names,tag,sep="_")
tag <- "sick"
num.plots <- 8
my.bins <- vector(num.plots,mode="list")
continent <- coord_selection(datatable,coord_cont)[[1]]
world <- map_data("world", "USA",exact="T",xlim=xbnds,ylim=ybnds)
data(us.cities)
us.cities <- data.table(us.cities)
filenames <- paste(img_names,tag,sep="_")
world <- map_data("world", "USA",exact="T",xlim=xbnds,ylim=ybnds)
data(us.cities)
us.cities <- data.table(us.cities)
colnames(us.cities)[4:5] <- c("latitude","longitude")
us.cities <- coord_selection(us.cities,coord_cont)[[1]]
us.cities <- us.cities[pop >2e5,]
my.bins[[1]] <- ggplot(continent,aes(longitude,latitude)) +
geom_map(data=world, map=world,
aes(x=long, y=lat, map_id=region),
color="white", fill="#7f7f7f", size=0.05, alpha=1/2)+
stat_bin_hex(binwidth=c(shape*0.5,0.5)) +
geom_point(data=us.cities,aes(x=longitude,y=latitude),size=1,color="orange")
tot <- as.data.table(ggplot_build(my.bins[[1]])$data[[2]]) #extracts count data of each hexbin
coord_tot <- round(tot[,.(x,y)],4)
coord_tot <- split(coord_tot, seq(nrow(coord_tot))) #split into list of (lon,lat)-tuples for comparison
temp <- continent[continent[,sick]==1,]
gc()
my.bins[[2]] <- ggplot(temp,aes(longitude,latitude)) +
geom_map(data=world, map=world,
aes(x=long, y=lat, map_id=region),
color="white", fill="#7f7f7f", size=0.05, alpha=1/2)+
stat_bin_hex(binwidth=c(shape*0.5,0.5)) +
geom_point(data=us.cities,aes(x=longitude,y=latitude),size=1,color="orange")
sick <- as.data.table(ggplot_build(my.bins[[2]])$data[[2]])
coord_sick <- round(sick[,.(x,y)],4)
coord_sick <- split(coord_sick, seq(nrow(coord_sick)))
ind_sick <- coord_sick %in% coord_tot
if (!all(ind_sick)){
stop("sick population is not a subset of total population")
}
ind_tot <- coord_tot %in% coord_sick
my.bins[[3]] <- ggplot(temp,aes(longitude,latitude)) +
stat_bin_hex(binwidth=c(shape*0.5,0.5))
my.bins[[3]] <- ggplot_build(my.bins[[3]])
my.bins[[3]] <- my.bins[[3]][1:2]
temp1 <- ggplot_build(my.bins[[2]])$data[[2]]
temp1$count <- sick$count[ind_sick]/tot$count[ind_tot]*1000 #calculating promille
test <- function(dataframe)
{
row <- as.vector(dataframe)
x <- as.matrix(rep(row[1],row[3]),row[3],1)
y <- as.matrix(rep(row[2],row[3]),row[3],1)
dat <- cbind(x,y)
}
x <- apply(temp1[c(1,2),c(2,3,5)],1,test)
x
x <- apply(temp1[,c(2,3,5)],1,test)
x
help(mapply)
mapply(rep,1:4,4:1)
mapply(c,1:4,4:1)
mapply(c,x)
x
rbind(x)
apply(x,1,rbind)
apply(x,rbind)
apply(x,2,rbind)
x
help(apply)
help(Reduce)
help(merge)
merge(x)
Reduce(merge,x)
x
merge(x[[1]],x[[2]])
x[[1]]
rbind(x[[1]],x[[2]])
help(mapply)
mapply(rbind,x)
help("apply")
as.vector(x)
as.array(x)
as.data.frame(x)
str(x)
help(unlist)
unlist(x)
unlist(x,recursive=F)
x
str()
str(s)
str(x)
as.matrix(x)
str(x[[|]])
str(x[[1]])
help(appl)
help(apply)
lapply(x,rbind)
sapply(x,rbind)
simplify2array(x)
str(simplify2array(x))
mapply(x)
mapply(cbind,x)
help(do.call)
do.call(rbind,x)
colnames(relative) <- c("longitude","latitude")
relative <- apply(temp1[,c(2,3,5)],1,row_multiplier)
row_multiplier <- function(dataframe)
{
row <- as.vector(dataframe)
x <- as.matrix(rep(row[1],row[3]),row[3],1)
y <- as.matrix(rep(row[2],row[3]),row[3],1)
dat <- cbind(x,y)
}
relative <- apply(temp1[,c(2,3,5)],1,row_multiplier)
relative <- do.call(rbind,relative)
colnames(relative) <- c("longitude","latitude")
head(relative)
my.bins[[3]] <- ggplot(relative,aes(longitude,latitude)) +
geom_map(data=world, map=world,
aes(x=long, y=lat, map_id=region),
color="white", fill="#7f7f7f", size=0.05, alpha=1/2)+
stat_bin_hex(binwidth=c(shape*0.5,0.5)) +
geom_point(data=us.cities,aes(x=longitude,y=latitude),size=1,color="orange")
relative <- apply(temp1[,c(2,3,5)],1,row_multiplier)
relative <- as.data.frame(do.call(rbind,relative))
colnames(relative) <- c("longitude","latitude")
my.bins[[3]] <- ggplot(relative,aes(longitude,latitude)) +
geom_map(data=world, map=world,
aes(x=long, y=lat, map_id=region),
color="white", fill="#7f7f7f", size=0.05, alpha=1/2)+
stat_bin_hex(binwidth=c(shape*0.5,0.5)) +
geom_point(data=us.cities,aes(x=longitude,y=latitude),size=1,color="orange")
my.bins[[3]]
temp <- continent[continent[,sick]==0,]
gc()
my.bins[[4]] <- hexbin(temp$longitude,temp$latitude,xbins=xbins,xbnds = xbnds, ybnds = ybnds,IDs=T,shape=shape)
#extract coordinates of bins based only on healthy tweets
healthy <- as.data.table(ggplot_build(my.bins[[4]])$data[[4]])
coord_healthy <- round(healthy[,.(x,y)],4)
coord_healthy <- split(coord_healthy, seq(nrow(coord_healthy)))
#extract indices of coord_tot which are also in coord_sick (and vice-versa)
ind_healthy <- coord_healthy %in% coord_tot
if (!all(ind_healthy)){
stop("healthy population is not a subset of total population")
}
ind_tot <- coord_tot %in% coord_healthy
#ratio of healthy tweets to total tweets
temp_data <- ggplot_build(my.bins[[4]])$data[[4]]
temp_data$count <- healthy$count[ind_healthy]/tot$count[ind_tot]*1000 #transforming to promille
relative <- apply(temp_data[,c(2,3,5)],1,row_multiplier)
relative <- as.data.frame(do.call(rbind,relative))
colnames(relative) <- c("longitude","latitude")
my.bins[[5]] <- ggplot(relative,aes(longitude,latitude)) +
geom_map(data=world, map=world,
aes(x=long, y=lat, map_id=region),
color="white", fill="#7f7f7f", size=0.05, alpha=1/2)+
stat_bin_hex(binwidth=c(shape*0.5,0.5)) +
geom_point(data=us.cities,aes(x=longitude,y=latitude),size=1,color="orange")
temp <- continent[continent[,sick]==0,]
gc()
my.bins[[4]] <- hexbin(temp$longitude,temp$latitude,xbins=xbins,xbnds = xbnds, ybnds = ybnds,IDs=T,shape=shape)
healthy <- as.data.table(ggplot_build(my.bins[[4]])$data[[4]])
healthy <- as.data.table(ggplot_build(my.bins[[4]])$data[[2]])
healthy <- as.data.table(ggplot_build(my.bins[[4]])$data[[2]])
my.bins[[4]]
my.bins[[4]] <- ggplot(temp,aes(longitude,latitude)) +
geom_map(data=world, map=world,
aes(x=long, y=lat, map_id=region),
color="white", fill="#7f7f7f", size=0.05, alpha=1/2)+
stat_bin_hex(binwidth=c(shape*0.5,0.5)) +
geom_point(data=us.cities,aes(x=longitude,y=latitude),size=1,color="orange")
healthy <- as.data.table(ggplot_build(my.bins[[4]])$data[[2]])
coord_healthy <- round(healthy[,.(x,y)],4)
coord_healthy <- split(coord_healthy, seq(nrow(coord_healthy)))
ind_healthy <- coord_healthy %in% coord_tot
if (!all(ind_healthy)){
stop("healthy population is not a subset of total population")
}
ind_tot <- coord_tot %in% coord_healthy
#ratio of healthy tweets to total tweets
temp_data <- ggplot_build(my.bins[[4]])$data[[4]]
temp_data$count <- healthy$count[ind_healthy]/tot$count[ind_tot]*1000 #
relative <- apply(temp_data[,c(2,3,5)],1,row_multiplier)
temp_data <- ggplot_build(my.bins[[4]])$data[[4]]
temp_data <- ggplot_build(my.bins[[4]])$data[[2]]
temp_data$count <- healthy$count[ind_healthy]/tot$count[ind_tot]*1000 #transforming to promille
relative <- apply(temp_data[,c(2,3,5)],1,row_multiplier)
relative <- as.data.frame(do.call(rbind,relative))
colnames(relative) <- c("longitude","latitude")
my.bins[[5]] <- ggplot(relative,aes(longitude,latitude)) +
geom_map(data=world, map=world,
aes(x=long, y=lat, map_id=region),
color="white", fill="#7f7f7f", size=0.05, alpha=1/2)+
stat_bin_hex(binwidth=c(shape*0.5,0.5)) +
geom_point(data=us.cities,aes(x=longitude,y=latitude),size=1,color="orange")
my.bins[[4]]
my.bins[[5]]
ind_tot
all(ind_tot)
sum(ind_tot)
length(ind_tot)
ind_healthy
sum(ind_healthy)
length(ind_healthy)
temp_data <- ggplot_build(my.bins[[4]])$data[[2]]
temp_data$count <- healthy$count[ind_healthy]/tot$count[ind_tot]*1000 #transforming to promille
temp_data$count
max(temp_data$count)
relative <- apply(temp_data[,c(2,3,5)],1,row_multiplier)
relative <- as.data.frame(do.call(rbind,relative))
colnames(relative) <- c("longitude","latitude")
my.bins[[5]] <- ggplot(relative,aes(longitude,latitude)) +
geom_map(data=world, map=world,
aes(x=long, y=lat, map_id=region),
color="white", fill="#7f7f7f", size=0.05, alpha=1/2)+
stat_bin_hex(binwidth=c(shape*0.5,0.5)) +
geom_point(data=us.cities,aes(x=longitude,y=latitude),size=1,color="orange")
temp_data <- ggplot_build(my.bins[[5]])$data[[2]]
temp_data$count
max(temp_data$count)
help(stat_bin_hex)
help(xlim)
my.bins[[5]] <- ggplot(relative,aes(longitude,latitude),xlim=xbnds,ylim=ybnds) +
geom_map(data=world, map=world,
aes(x=long, y=lat, map_id=region),
color="white", fill="#7f7f7f", size=0.05, alpha=1/2)+
stat_bin_hex(binwidth=c(shape*0.5,0.5)) +
geom_point(data=us.cities,aes(x=longitude,y=latitude),size=1,color="orange")
my.bins[[5]]
my.bins[[4]] <- ggplot(temp,aes(longitude,latitude),xlim=xbnds,ylim=ybnds) +
geom_map(data=world, map=world,
aes(x=long, y=lat, map_id=region),
color="white", fill="#7f7f7f", size=0.05, alpha=1/2)+
stat_bin_hex(binwidth=c(shape*0.5,0.5)) +
geom_point(data=us.cities,aes(x=longitude,y=latitude),size=1,color="orange")
healthy <- as.data.table(ggplot_build(my.bins[[4]])$data[[2]])
coord_healthy <- round(healthy[,.(x,y)],4)
healthy <- as.data.table(ggplot_build(my.bins[[4]])$data[[2]])
coord_healthy <- round(healthy[,.(x,y)],4)
coord_healthy <- split(coord_healthy, seq(nrow(coord_healthy)))
ind_healthy <- coord_healthy %in% coord_tot
if (!all(ind_healthy)){
stop("healthy population is not a subset of total population")
}
ind_tot <- coord_tot %in% coord_healthy
#ratio of healthy tweets to total tweets
temp_data <- ggplot_build(my.bins[[5]])$data[[2]]
temp_data$count <- healthy$count[ind_healthy]/tot$count[ind_tot]*1000 #transforming to promille
relative <- apply(temp_data[,c(2,3,5)],1,row_multiplier)
relative <- as.data.frame(do.call(rbind,relative))
colnames(relative) <- c("longitude","latitude")
my.bins[[5]] <- ggplot(relative,aes(longitude,latitude),xlim=xbnds,ylim=ybnds) +
geom_map(data=world, map=world,
aes(x=long, y=lat, map_id=region),
color="white", fill="#7f7f7f", size=0.05, alpha=1/2)+
stat_bin_hex(binwidth=c(shape*0.5,0.5)) +
geom_point(data=us.cities,aes(x=longitude,y=latitude),size=1,color="orange")
my.bins[[4]]
my.bins[[5]]
qplot(longitude, latitude, data = temp, geom="hex", xlim = xbnds, ylim = ybnds,
binwidth=c(shape*0.5,0.5))
temp
qplot(longitude, latitude, data = temp, geom="hex", xlim = xbnds, ylim = ybnds,
binwidth=c(shape*0.5,0.5))
qplot(longitude, latitude, data = relative, geom="hex", xlim = xbnds, ylim = ybnds,
binwidth=c(shape*0.5,0.5))
relative
temp1 <- ggplot_build(my.bins[[2]])
temp2 <- ggplot_gtable(temp1)
str(temp2)
ggplot(temp2)
gtable
temp2
plot(temp2)
str(temp2)
gtable$
a
temp2$grobs
temp2$layout
temp1 <- ggplot(temp,aes(longitude,latitude)) +
stat_bin_hex(binwidth=c(shape*0.5,0.5)) +
temp1 <- ggplot_build(my.bins[[2]])
temp1 <- ggplot(temp,aes(longitude,latitude)) +
stat_bin_hex(binwidth=c(shape*0.5,0.5))
temp1 <- ggplot_build(temp1)
temp2 <- ggplot_gtable(temp1)
temp2
str(temp2)
temp2$layout
help("grob")
temp2
str(temp2)
temp2$grobs
temp2$grobs[[1]]
temp2$grobs[[15]]
temp1[1]
temp1[c(1,2)]
temp1A <- temp1[c(1,2)]
temp2 <- ggplot_gtable(temp1A)
str(temp1A)
temp2 <- ggplot_gtable(temp1A)
temp2 <- ggplot_gtable(temp1)
